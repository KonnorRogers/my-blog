{"componentChunkName":"component---src-templates-blog-post-js","path":"/ruby/dynamic_getters_and_setters/","result":{"data":{"site":{"siteMetadata":{"title":"Konnor's Blog","author":"Konnor Rogers"}},"mdx":{"id":"ef2608af-af49-5933-af0f-a4da250a962b","excerpt":"So I'm currently making a Rubygem called\n Snowpacker  and I ran into\nan interesting problem. In Snowpacker, I allow users to define various attributes within aâ€¦","frontmatter":{"title":"Dynamic Getters and Setters on an Object","date":"August 10, 2020"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dynamic Getters and Setters on an Object\",\n  \"date\": \"2020-08-10T15:35:09\",\n  \"description\": \"A guide to defining dynamic getters and setters on a Ruby Object\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    id: \"problem\"\n  }, mdx(\"a\", {\n    href: \"#problem\"\n  }, \"The Problem\")), mdx(\"p\", null, \"So I\\u2019m currently making a Rubygem called\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/paramagicdev/snowpacker\"\n  }), \"Snowpacker\"), \" and I ran into\\nan interesting problem.\"), mdx(\"p\", null, \"In Snowpacker, I allow users to define various attributes within a Rails app initializer like so:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\",\n    \"metastring\": \"title=rails_app/config/initializers/snowpacker.rb\",\n    \"title\": \"rails_app/config/initializers/snowpacker.rb\"\n  }), \"Snowpacker.configure do |snowpacker|\\n  snowpacker.config_dir = Rails.root.join(\\\"config\\\", \\\"snowpacker\\\")\\n  # ... more options\\nend\\n\")), mdx(\"p\", null, \"The code to set this up is fairly straight forward. In my gem I have the\\nfollowing 2 files:\"), mdx(\"p\", null, \"First, we have to make a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configuration\"), \" object.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\",\n    \"metastring\": \"title=lib/snowpacker/configuration.rb\",\n    \"title\": \"lib/snowpacker/configuration.rb\"\n  }), \"module Snowpacker\\n  class Configuration\\n    attr_accessor :config_dir\\n    attr_accessor :config_file\\n    attr_accessor :babel_config_file\\n\\n    # ... more accessors\\n\\n  end\\nend\\n\")), mdx(\"p\", null, \"Then, we need to make the configuration available project wide. To do\\nso, we have to create a class method to define a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configuration\"), \" instance\\nand then we create an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attr_accessor\"), \" to be able to set & get the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configuration\"), \" values. In a nutshell we want to be able to do the\\nfollowing:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\"\n  }), \"Snowpacker.configure do |snowpacker|\\n  snowpacker.config.attr = \\\"value\\\"\\nend\\n\")), mdx(\"p\", null, \"As well as be able to do this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\"\n  }), \"Snowpacker.config.attr = \\\"other value\\\"\\n\")), mdx(\"p\", null, \"To do so, we have to do the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\",\n    \"metastring\": \"title=lib/snowpacker.rb\",\n    \"title\": \"lib/snowpacker.rb\"\n  }), \"# ... other require statements\\nrequire \\\"snowpacker/configuration\\\"\\n\\nmodule Snowpacker\\n  # Everything below this is the same as def self.method; stuff; end\\n  class << self\\n    attr_accessor :config\\n\\n    def configure\\n      self.config ||= Configuration.new\\n      yield(config) if block_given?\\n    end\\n  end\\nend\\n\")), mdx(\"p\", null, \"So now everything works as expected. There\\u2019s just one problem. What if a\\nuser wants to define another \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attr_accessor\"), \"? I can\\u2019t possibly account\\nfor this. So, lets look at how to define a dynamic \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attr_accessor\"), \".\"), mdx(\"h2\", {\n    id: \"attr_accessor\"\n  }, mdx(\"a\", {\n    href: \"#attr_accessor\"\n  }, \"What does attr_accessor actually do?\")), mdx(\"p\", null, \"Well first, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attr_accessor\"), \" combines \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attr_writer\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attr_reader\"), \".\"), mdx(\"p\", null, \"Totally not helpful right? Well lets break it down further.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attr_writer :name\"), \" is the equivalent of:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\"\n  }), \"def name\\n  @name\\nend\\n\")), mdx(\"p\", null, \"And \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attr_reader :name\"), \" is the equivalent of:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\"\n  }), \"def name=(value)\\n  @name = value\\nend\\n\")), mdx(\"p\", null, \"So \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attr_accessor\"), \" neatly provides the 2 above methods for us.\"), mdx(\"p\", null, \"The only issue is, you can\\u2019t technically dynamically define an\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attr_accessor\"), \", instead, you have to manually define both methods listed\\nabove to achieve the same functionality.\"), mdx(\"h2\", {\n    id: \"why-care\"\n  }, mdx(\"a\", {\n    href: \"#why-care\"\n  }, \"Why should I care?\")), mdx(\"p\", null, \"But Konnor, why does that matter? Well the reason it matters is that in\\nmy \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"snowpack.config.js\"), \" I read the value of Environment variables to\\nmake certain things behave in certain ways. The way these values are\\nset are via instance variables that are read from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configuration\"), \" object. Basically, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Snowpacker\"), \" will take all\\nthe instance_variables of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configuration\"), \" object and prepend\\n\\u201CSNOWPACKER\", \"_\", \"\\u201D to them.\"), mdx(\"p\", null, \"For example, if you\\u2019re given the following code:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\",\n    \"metastring\": \"title=rails_app/config/initializers/snowpacker.rb\",\n    \"title\": \"rails_app/config/initializers/snowpacker.rb\"\n  }), \"Snowpacker.configure do |snowpacker|\\n  snowpacker.config_dir = Rails.root.join(\\\"config\\\", \\\"snowpacker\\\")\\n  snowpacker.babel_config_file = File.join(snowpacker.config_dir,\\n  \\\"babel.config.js\\\")\\n  # ... more options\\nend\\n\")), mdx(\"p\", null, \"What Snowpacker will do at runtime is create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SNOWPACKER_CONFIG_DIR\"), \"\\nenvironment variable as well as a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SNOWPACKER_BABEL_CONFIG_FILE\"), \". Both\\nvalues can now be accessed via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ENV[\\\"SNOWPACKER_CONFIG_DIR\\\"]\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ENV[\\\"SNOWPACKER_BABEL_CONFIG_FILE\\\"]\"), \" respectively.\"), mdx(\"h2\", {\n    id: \"okay-cool\"\n  }, mdx(\"a\", {\n    href: \"#okay-cool\"\n  }, \"Okay, fine, its important, so whats the next step?\")), mdx(\"p\", null, \"Initially I had a very ugly non-idiomatic workaround. Then it dawned on\\nme to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"method_missing\"), \" approach.\"), mdx(\"p\", null, \"In a nutshell, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"method_missing\"), \" is a method defined on every\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Object\"), \" that checks to see if a method exists. If it does not exist, it\\nprints a stacktrace and raises a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NoMethodError\"), \". So what we\\u2019re doing is\\noverriding the existing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"method_missing\"), \" on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configuration\"), \" Object\\nto be able to dynamically define methods. Rails makes heavy use of this\\npattern.\"), mdx(\"p\", null, \"Here\\u2019s how I setup dynamic attribute getting and setting in Snowpacker.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\",\n    \"metastring\": \"title=lib/snowpacker/configuration.rb\",\n    \"title\": \"lib/snowpacker/configuration.rb\"\n  }), \"module Snowpacker\\n  class Configuration\\n    attr_accessor :config_dir\\n    # ... Other base accessors\\n`\\n    def method_missing(method_name, *args, &block)\\n      # Check if the method missing is an \\\"attr=\\\" method\\n      raise unless method_name.to_s.end_with(\\\"=\\\")\\n\\n      setter = method_name\\n      getter = symbol.to_s.slice(0...-1).to_sym\\n      instance_var = \\\"@#{getter}\\\".to_sym\\n\\n      define_singleton_method(setter) do |new_val|\\n        instance_variable_set(instance_var, new_val)\\n      end\\n\\n      define_singleton_method(getter) { instance_variable_get(instance_var) }\\n\\n      # Ignores all arguments but the first one\\n      value = args[0]\\n\\n      # Actually sets the value on the instance variable\\n      send(setter, value)\\n    rescue\\n      # Raise error as normal, nothing to see here\\n      super(symbol, *args, &block)\\n    end\\n  end\\nend\\n\")), mdx(\"p\", null, \"So now with the above we could add an attr onto our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configuration\"), \"\\nobject without worry about adding an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attr_accessor\"), \".\"), mdx(\"h2\", {\n    id: \"dont-get-it\"\n  }, mdx(\"a\", {\n    href: \"#dont-get-it\"\n  }, \"Yea...I dont get it, whats happening?\")), mdx(\"p\", null, \"If you\\u2019re sitting there scratching your head, I don\\u2019t blame you.\\nThis may seem like a lot but lets break it down line by line.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"def method_missing(symbol, *args, &block)\")), mdx(\"p\", null, \"All this means is that we\\u2019re overriding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"method_missing\"), \" for all\\nConfiguration Objects.\"), mdx(\"br\", null), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"raise unless symbol.to_s.end_with(\\\"=\\\")\")), mdx(\"p\", null, \"If the method name does not end with an equal sign, raise an error.\\nIn other words, we want to raise an error if the method we\\u2019re trying to\\ncall is not a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setter\"), \" (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attr=\"), \"). That\\u2019s it, pretty cool right!\"), mdx(\"p\", null, \"Heres an example of what we want:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\"\n  }), \"Snowpacker.config.test # will raise an error\\n\\nSnowpacker.config.test = \\\"value\\\" # will not raise an error.\\nSnowpacker.config.test # now returns \\\"value\\\"\\n\")), mdx(\"p\", null, \"So now that we know we\\u2019re only dealing with methods that look like\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"random_attribute=\"), \" we can start making more assumptions.\"), mdx(\"br\", null), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setter = symbol\"), \" we\\u2019re just renaming the argument to make our intent more clear.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getter = symbol.to_s.slice(0...-1).to_sym\"), \" Because the setter method\\ncontains an equal sign, the getter cannot contain the equal sign. So to\\nfix this we turn it to a string, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"slice\"), \" off the equal sign at the end,\\nthen convert it back to a symbol so we can use it as a method.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"instance_var = \\\"@#{getter}\\\".to_sym\"), \" When we create add an instance\\nvariable it must be in the form:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":@example_instance_variable\"), \" so all we\\u2019re doing here is prepending a \\u201D@\\u201D to tell Ruby that its an instance variable.\"), mdx(\"p\", null, \"Alright now we\\u2019re getting to do the actual work:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\"\n  }), \"define_singleton_method(setter) do |new_val|\\n  instance_variable_set(instance_var, new_val)\\nend\\n\")), mdx(\"p\", null, \"This is our setter method. What we\\u2019re saying is \\u201Ccreate a method in the\\nform \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"variable_name=(value)\"), \". In other words, we\\u2019re recreating\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attr_writer\"), \" here. This allows us to write new values to the instance\\nvariable.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"define_singleton_method(getter) { instance_variable_get(instance_var) }\")), mdx(\"p\", null, \"So if the previous method was the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attr_writer\"), \", this is the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attr_reader\"), \". So now we technically have the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attr_accessor\"), \"\\nfunctionality we were looking for, theres one issue though. When a user\\ngoes to set the value for the first time, it wont actually set. To fix\\nthis we implement the below code:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\"\n  }), \"value = args[0]\\nsend(setter, value)\\n\")), mdx(\"p\", null, \"This sets our instance variable to the value we passed in.\"), mdx(\"p\", null, \"For example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\"\n  }), \"Snowpacker.config.test_attr = \\\"attr_value\\\"\\n# \\\"test_attr\\\" is the setter\\n# \\\"attr_value\\\" is the value\\n\")), mdx(\"p\", null, \"Alright so thats all the logic. But what does that last little bit do?\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"rescue\\n  super(method_name, *args, &block)\\nend\\n\")), mdx(\"p\", null, \"All this does, is if any error occurs, send it up the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"method_missing\"), \"\\ncall chain and raise a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NoMethodError\"), \".\"), mdx(\"p\", null, \"That\\u2019s it. Wield this new found power wisely!\"), mdx(\"h2\", {\n    id: \"links\"\n  }, mdx(\"a\", {\n    href: \"#links\"\n  }, \"Links\")), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ParamagicDev/snowpacker\"\n  }), \"Snowpacker\")), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ParamagicDev/snowpacker/blob/master/lib/snowpacker/configuration.rb\"\n  }), \"Snowpacker Configuration\\nFile\")), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://ruby-doc.org/core-2.7.0/BasicObject.html#method-i-method_missing\"\n  }), \"Method Missing\\nDocumentation\")), mdx(\"h2\", null, \"Extra cleanup\"), mdx(\"p\", null, \"If you use a linter, it will probably tell you to define a\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"respond_to_missing?\"), \" method. It\\u2019s really not needed here since we\\u2019re\\ndirectly defining methods, but if you want to make your linter happy,\\nhere ya go:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\"\n  }), \"def respond_to_missing?(method_name, include_private = false)\\n  method_name.to_s.end_with?(\\\"=\\\") || super\\nend\\n\")), mdx(\"p\", null, \"We\\u2019re just telling Ruby, any method that ends with an equal sign is\\nactually a method for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configuration\"), \" Object.\"), mdx(\"p\", null, \"Heres the Thoughtbot post on it:\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://thoughtbot.com/blog/always-define-respond-to-missing-when-overriding\"\n  }), \"https://thoughtbot.com/blog/always-define-respond-to-missing-when-overriding\")), mdx(\"p\", null, \"Happy Rubying, or whatever the kids say these days!\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/ruby/dynamic_getters_and_setters/","previous":{"id":"8473e4e2-bed8-523e-99da-a507b31d4be8","fields":{"slug":"/bridgetownrb/converting-bridgetown-to-snowpack/"},"frontmatter":{"title":"Convert a Bridgetown site with to Snowpack"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Convert a Bridgetown site with to Snowpack\",\n  \"date\": \"2020-07-09T17:57:41\",\n  \"description\": \"A detailed description of converting a Bridgetown site that uses webpack over to snowpack.\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Foreword\"), mdx(\"p\", null, \"I am going to use an already built project to help demonstrate\\nsome of the issues you may face. If you have not started your site yet,\\nheres a template using snowpack.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ParamagicDev/portfolio/tree/reference/bridgetown\"\n  }), \"Bridgetown with Snowpack Template\")), mdx(\"h2\", null, \"Getting started\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"next":null}}}