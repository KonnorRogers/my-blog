{"componentChunkName":"component---src-templates-blog-post-js","path":"/rails/active-storage-variants-rails-6-1/","result":{"data":{"site":{"siteMetadata":{"title":"Konnor's Blog","author":"Konnor Rogers"}},"mdx":{"id":"6d93ea9c-b4fb-5338-b406-f6c3dbf4ff12","excerpt":"Upgrading to Rails 6.1 and encountering the following error? ActiveRecord::NotNullViolation (PG::NotNullViolation: ERROR: null value\nin column \"record_id\" ofâ€¦","frontmatter":{"title":"Active Storage Variants with Rails 6.1","date":"February 24, 2021"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Active Storage Variants with Rails 6.1\",\n  \"date\": \"2021-02-24T14:12:29\",\n  \"description\": \"receiving the following error with ActiveStorage Variants with Rails 6.1? ActiveRecord::NotNullViolation (PG::NotNullViolation: ERROR:  null value in column 'record_id' of relation 'active_storage_attachments' violates not-null constraint) Let me help!\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    id: \"error\"\n  }, mdx(\"a\", {\n    href: \"#error\"\n  }, \"The Error!\")), mdx(\"p\", null, \"Upgrading to Rails 6.1 and encountering the following error?\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"ActiveRecord::NotNullViolation (PG::NotNullViolation: ERROR: null value\\nin column \\u201Crecord_id\\u201D of relation \\u201Cactive_storage_attachments\\u201D violates\\nnot-null constraint)\")), mdx(\"p\", null, \"Let me save you a couple hours!\"), mdx(\"p\", null, \"Lets back up a step. Are you using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t.uuid :record_id\"), \" (is your\\nrecord_id for ActiveStorage a uuid?)\"), mdx(\"p\", null, \"If you\\u2019re not sure, you can check your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"db/schema.rb\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\",\n    \"metastring\": \"title=db/schema.rb\",\n    \"title\": \"db/schema.rb\"\n  }), \"  create_table \\\"active_storage_attachments\\\", force: :cascade do |t|\\n    # ...\\n    t.uuid \\\"record_id\\\", null: false\\n    # ...\\n  end\\n\")), mdx(\"p\", null, \"If yes, keep reading. If not, sorry, this wont be much help.\"), mdx(\"h2\", {\n    id: \"using-uuid-me-too\"\n  }, mdx(\"a\", {\n    href: \"#using-uuid-me-too\"\n  }, \"Using UUID for record_id, cool I was too\")), mdx(\"p\", null, \"Alright now that we\\u2019ve located the source how do we fix it?\"), mdx(\"p\", null, \"When you run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rails app:update\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rails active_storage:update\"), \" it will\\ncreate 2 migrations for you. In particular we want to look at the one\\ngenerating the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"active_storage_variant_records\"), \" table. The file should look\\nsomething like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\",\n    \"metastring\": \"title=db/migrate/xxxx_create_active_storage_variant_records.active_storage.rb\",\n    \"title\": \"db/migrate/xxxx_create_active_storage_variant_records.active_storage.rb\"\n  }), \"class CreateActiveStorageVariantRecords < ActiveRecord::Migration[6.0]\\n  def change\\n    create_table :active_storage_variant_records do |t|\\n      t.belongs_to :blob, null: false, index: false\\n      t.string :variation_digest, null: false\\n\\n      t.index %i[ blob_id variation_digest ], name: \\\"index_active_storage_variant_records_uniqueness\\\", unique: true\\n      t.foreign_key :active_storage_blobs, column: :blob_id\\n    end\\n  end\\nend\\n\")), mdx(\"p\", null, \"From here the fix is just to add a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uuid\"), \" constraint for the id like so:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"title=db/migrate/xxxx_create_active_storage_variant_records.active_storage.rb\",\n    \"title\": \"db/migrate/xxxx_create_active_storage_variant_records.active_storage.rb\"\n  }), \"class CreateActiveStorageVariantRecords < ActiveRecord::Migration[6.0]\\n  def change\\n-    create_table :active_storage_variant_records do |t|\\n+    create_table :active_storage_variant_records, id: :uuid do |t|\\n     # ...\\n  end\\nend\\n\")), mdx(\"p\", null, \"Now rollback your migrations, rerun your migrations, and onward to\\nvictory!!\"), mdx(\"h2\", {\n    id: \"links\"\n  }, mdx(\"a\", {\n    href: \"#links\"\n  }, \"Links\")), mdx(\"h3\", {\n    id: \"active-storage-docs\"\n  }, mdx(\"a\", {\n    href: \"#active-storage-docs\"\n  }, \"Active Storage docs\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://edgeguides.rubyonrails.org/active_storage_overview.html#setup\"\n  }), \"https://edgeguides.rubyonrails.org/active_storage_overview.html#setup\"))), mdx(\"h3\", {\n    id: \"rails-6-1-migration\"\n  }, mdx(\"a\", {\n    href: \"#rails-6-1-migration\"\n  }, \"Rails 6.1 migration docs\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Release notes:\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://edgeguides.rubyonrails.org/6_1_release_notes.html\"\n  }), \"https://edgeguides.rubyonrails.org/6_1_release_notes.html\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Upgrade guide: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://guides.rubyonrails.org/upgrading_ruby_on_rails.html\"\n  }), \"https://guides.rubyonrails.org/upgrading_ruby_on_rails.html\")))));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/rails/active-storage-variants-rails-6-1/","previous":{"id":"349d4e47-476d-53fa-9ba9-295fb58c331d","fields":{"slug":"/misc/bundlers-and-beyond/"},"frontmatter":{"title":"Webpack, Rollup, Parcel, Snowpack, and beyond"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Webpack, Rollup, Parcel, Snowpack, and beyond\",\n  \"date\": \"2020-09-29T15:32:30\",\n  \"description\": \"A brief comparison between popular frontend bundlers. I will walk through my thoughts and feelings related to each bundler\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    id: \"is-not\"\n  }, mdx(\"a\", {\n    href: \"#is-not\"\n  }, \"What this post is not\")), mdx(\"p\", null, \"This post will not get into bundle sizes, compilation times, and the\\nnitty gritty of each bundler. But why? I wanna see the numbers!! The\\nissue is each bundler uses different loaders based on the file type. Not\\nall loaders are created equally and frankly, it would require a lot of\\neffort to go through each individual loader for each bundler and create\\nbenchmarks. Instead, this post is a brief high-level overview of\\ndifferent frontend bundlers and the general problems they try to solve.\"), mdx(\"h2\", {\n    id: \"history\"\n  }, mdx(\"a\", {\n    href: \"#history\"\n  }, \"History\")), mdx(\"p\", null, \"Why do we need bundlers? Browser-based Javascript prior to ES6\\n(introduced in 2015) had no way of\\nimporting a file natively. Instead you either chained \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<script>\"), \" tags,\\nor you had one massive Javascript file you would ship to the browser.\\nFor example you may have the following in your HTML.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-html\"\n  }), \"<script src=\\\"https://code.jquery.com/jquery-3.5.1.min.js\\\"></script>\\n<script src=\\\"/dist/my-awesome-script.js\\\"></script>\\n\")), mdx(\"p\", null, \"Now we get into the issue of, if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"my-awesome-script.js\"), \" depends on\\njQuery to load, what happens if loading the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"jQuery\"), \" script fails? Is\\nmy site now broken? You can quickly see why this is an issue. It gets\\nworse when you also realize that you cant break up your Javascript files\\ninto smaller more manageable files.\"), mdx(\"h2\", {\n    id: \"solution\"\n  }, mdx(\"a\", {\n    href: \"#solution\"\n  }, \"The solution\")), mdx(\"p\", null, \"As far as I can tell \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://webpack.js.org/\"\n  }), \"Webpack\"), \" was the first\\nfrontend bundler on the scene. It appeared in 2015, around the same time as\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://browserify.org/\"\n  }), \"Browserify\"), \". Webpack\\u2019s goal was simple, allow\\nfor assets and javascript to be made more atomic yet still bundled\\nnicely for production. Since Webpack was released there have been many\\nmore frontend bundlers released IE: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://parceljs.org/\"\n  }), \"Parcel\"), \",\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://rollupjs.org/guide/en/\"\n  }), \"Rollup\"), \", and most recently there have\\nbeen a number of ES Module based \\u201Cbundlers\\u201D (still not sure bundler is\\nthe right term) released such as\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.snowpack.dev/\"\n  }), \"Snowpack\"), \" and\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/vitejs/vite\"\n  }), \"Vite\"), \".\"), mdx(\"h2\", {\n    id: \"bundlers\"\n  }, mdx(\"a\", {\n    href: \"#bundlers\"\n  }, \"Bundlers\")), mdx(\"p\", null, \"There are currently 3 major traditional frontend bundlers that most\\npeople talk about. \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://webpack.js.org\"\n  }), \"Webpack\"), \",\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://rollupks.org\"\n  }), \"Rollup\"), \", and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://parceljs.org\"\n  }), \"Parcel\"), \".\"), mdx(\"h3\", {\n    id: \"choosing\"\n  }, mdx(\"a\", {\n    href: \"#choosing\"\n  }, \"Choosing the right one for you\")), mdx(\"h4\", {\n    id: \"webpack\"\n  }, mdx(\"a\", {\n    href: \"#webpack\"\n  }, \"Webpack\")), mdx(\"p\", null, \"\\u201CWebpack is for websites\\u201D, Webpack is the oldest of the 3 bundlers.\\nWebpack, in my opinion, is also the most complicated to setup of the 3\\nbundlers. This isn\\u2019t a knock against Webpack, it\\u2019s a super powerful tool,\\nbut it is also quite complex. The reason people say this is that historically\\nWebpack was used for websites, but theres no reason you can\\u2019t use it for\\nan NPM package.\"), mdx(\"h4\", {\n    id: \"rollup\"\n  }, mdx(\"a\", {\n    href: \"#rollup\"\n  }, \"Rollup\")), mdx(\"p\", null, \"\\u201CRollup is for libraries\\u201D, Rollup is significantly more minimal than\\nWebpack, Rollup doesnt even include a dev server! Rollup was released\\nshortly after Webpack, based on my search around 2016. When it was first\\nreleased it had minimal support for assets such as CSS, images, etc.\\nHowever, nowadays Rollup is just as full featured as Webpack. There\\u2019s no\\nreason you can\\u2019t use it for websites.\"), mdx(\"h4\", {\n    id: \"parcel\"\n  }, mdx(\"a\", {\n    href: \"#parcel\"\n  }, \"Parcel\")), mdx(\"p\", null, \"Parcel is the newest of the 3 appearing at the beginning of 2018. Parcel\\nstates it is a \\u201CBlazing fast, zero configuration web application\\nbundler\\u201D. Now I have the least experience with Parcel, however, my\\nexperience with Parcel has been nothing short of awesome. It holds true\\nto its promise. It even supports both HTML and JS entrypoints. A lot of\\nthe issues people had with Parcel initially when it was first released\\nwas the size of its bundles. They have made great strides to be on par\\nwith Rollup and Webpack.\"), mdx(\"h3\", {\n    id: \"ok\"\n  }, mdx(\"a\", {\n    href: \"#ok\"\n  }, \"OK...So what is right for me?\")), mdx(\"p\", null, \"Try all 3, see which one you like best. They honestly all accomplish the\\nsame task and can do roughly the same thing. As of Webpack 4, ESM is\\nnatively supported. Assets are fully supported by Rollup. Parcel bundle\\nsizes are significantly smaller than they used to be. Seriously, just\\ntry them. The only caveat is that as far as I can tell Parcel is only\\nfor web apps and does not support bundling for NPM.\"), mdx(\"h2\", {\n    id: \"new-stuff\"\n  }, mdx(\"a\", {\n    href: \"#new-stuff\"\n  }, \"A new challenger approaches\")), mdx(\"p\", null, \"ESM-based frontend \\u201Cbundlers\\u2026compilers?\\u201D, I don\\u2019t know what to call\\nthem\\u2026  are the cool new thing in the web dev world. They independently\\nbuild each file in parallel getting rid of the traditional compilation\\nstep that people complain about with traditional bundlers.\"), mdx(\"p\", null, \"The current issue with compilation is it can be quite slow, especially\\nwhen you stop to consider changing 1 file can trigger a rebuild of your\\nentire bundle including babel transforms, postcss builds, and everything\\nin between.\"), mdx(\"p\", null, \"The new ESM-based build tools like Snowpack and Vite leverage the ES6\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"import / export\"), \" syntax to be able to provide blazing fast unbundled\\ndevelopment environments to increase productivity. This means the\\ncompilation step is gone! No more waiting for bundles to regenerate.\"), mdx(\"p\", null, \"Everything is independent. There is no massive recompilation on a single\\nfile change. It also more closely mimics a browser environment which all\\nevergreen browsers (Chrome, Edge, Firefox) fully support ESM-based\\nimport / export syntax. And with the advent of HTTP/2 protocols, the\\nissue of multiple waterfall network requests may soon be a thing of the\\npast for assets.\"), mdx(\"p\", null, \"Right now adoption is quite fast even though ESM-based compilers are fairly new.\\nThey have gained a significant amount of traction in the web\\ndevelopment community.\"), mdx(\"p\", null, \"In fact, I\\u2019m currently working on\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/paramagicdev/snowpacker\"\n  }), \"Snowpacker\"), \", a Ruby on\\nRails integration with Snowpack to bring unbundled development\\nenvironments to the Rails world. The project is not quite ready for\\nrelease yet, but significant strides have been made and a release should\\nbe on the horizon.\"), mdx(\"h2\", {\n    id: \"summary\"\n  }, mdx(\"a\", {\n    href: \"#summary\"\n  }, \"Summary\")), mdx(\"p\", null, \"Parcel, Webpack, and Rollup are all great. Use whichever one you want.\\nHistorically Webpack was for websites due to its full feature set,\\nRollup was for libraries due to lack of asset handling and minimalism,\\nand Parcel was for prototypes due to large bundle sizes, but I feel all\\n3 statements above are no longer true due to vast improvements by all 3\\nlibraries, use whatever you are most comfortable with.\"), mdx(\"p\", null, \"ESM-based build tools like Vite and Snowpack are showing great promise\\nand appear to be the future of the frontend.\"), mdx(\"h2\", {\n    id: \"links\"\n  }, mdx(\"a\", {\n    href: \"#links\"\n  }, \"Links\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://webpack.js.org/\"\n  }), \"Webpack\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://rollupjs.org/guide/en/\"\n  }), \"Rollup\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://parceljs.org/\"\n  }), \"Parcel\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/vitejs/vite\"\n  }), \"Vite\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.snowpack.dev/\"\n  }), \"Snowpack\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://githubm.com/paramagicdev/snowpacker\"\n  }), \"Snowpacker\")))));\n}\n;\nMDXContent.isMDXComponent = true;"},"next":{"id":"64ced3bf-b65c-5164-9f76-c99e1a06fd59","fields":{"slug":"/rails/differences-between-javascript-and-rails-timezones/"},"frontmatter":{"title":"Differences between JavaScript and Rails timezones"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Differences between JavaScript and Rails timezones\",\n  \"date\": \"2021-03-05T12:33:46\",\n  \"description\": \"Common pitfalls and issues with Rails timezones. Differences between the browser and the server, and various other tidbits.\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"What I\\u2019m working on\"), mdx(\"p\", null, \"I work for VeueLive (\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://veue.tv\"\n  }), \"https://veue.tv\"), \") and recently was tasked with\\ncreating a scheduling form for streamers.\"), mdx(\"h2\", null, \"What I was tasked with:\"), mdx(\"p\", null, \"When working on this I had a design that looks as follows:\"), mdx(\"form\", null, mdx(\"div\", {\n    style: {\n      \"marginBottom\": \"1rem\"\n    }\n  }, mdx(\"select\", null, mdx(\"option\", {\n    value: \"\"\n  }, \"Pick a Day\"), mdx(\"option\", {\n    value: \"1\"\n  }, \"5 March 2021 (Today) \"), mdx(\"option\", {\n    value: \"2\"\n  }, \"6 March 2021 (Tomorrow) \"), mdx(\"option\", {\n    value: \"3\"\n  }, \"7 March 2021 \"))), mdx(\"div\", null, mdx(\"select\", null, mdx(\"option\", {\n    value: \"\"\n  }, \"Pick a Time (Time Zone)\"), mdx(\"option\", {\n    value: \"15\"\n  }, \"00:15 (EST)\"), mdx(\"option\", {\n    value: \"30\"\n  }, \"00:30 (EST)\")))), mdx(\"p\", null, \"And then on the Rails backend I had a schema that looked roughly like\\nthis:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\"\n  }), \"create_table \\\"videos\\\" do |t|\\n  t.datetime :scheduled_at\\nend\\n\")), mdx(\"p\", null, \"So I had a few options, I decided to prefill a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<input type=\\\"hidden\\\"\\nname=\\\"video[scheduled_at]>\"), \" field and then use a Stimulus controller to\\nwire everything together to send off a coherent \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"datetime\"), \" to the\\nserver.\"), mdx(\"p\", null, \"Im not going to get into how I actually built this because it will be\\nquite verbose, instead, Im going to document the inconsistencies I found\\nbetween Javascript and Rails and some of the pitfalls.\"), mdx(\"h2\", null, \"Dates arent what they seem.\"), mdx(\"h3\", null, \"Month of year\"), mdx(\"p\", null, \"The month of the year is 0 indexed in JS and 1-indexed in Ruby.\"), mdx(\"h4\", null, \"Javascript\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// month of year\\nnew Date().getMonth()\\n// => 0 (January), 1 (February), 2 (March), ... 11 (December)\\n// 0-indexed month of the year\\n\")), mdx(\"h4\", null, \"Ruby / Rails\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\"\n  }), \"# month of year\\nTime.current.month\\n# => 1 (January), 2 (February), 3 (March), ... 12 (December)\\n# 1-indexed month of the year\\n\")), mdx(\"h3\", null, \"Day of Week\"), mdx(\"p\", null, \"The day of the week in JavaScript is called via:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new Date().getDay()\")), mdx(\"p\", null, \"And in Rails its:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Time.current.wday\")), mdx(\"h4\", null, \"Javascript\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Day of the week\\nnew Date().getDay()\\n// => 0 (Sunday) ... (6 Saturday)\\n// 0-indexed day of week\\n\")), mdx(\"h4\", null, \"Ruby / Rails\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\"\n  }), \"# Day of the week\\ntime.wday\\n# => 0 (Sunday) ... 6 (Saturday)\\n# 0-indexed day of week\\n\")), mdx(\"h3\", null, \"Day of Month\"), mdx(\"h4\", null, \"Javascript\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Day of the month\\ndate.getDate()\\n// => 1 (day 1 of month), ..., 11 (day 11 of month), 28 ... 31 (end of month)\\n// 1-indexed day of the month\\n\")), mdx(\"h4\", null, \"Ruby / Rails\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\"\n  }), \"# Day of month\\ntime.day\\n# => 1 (first day), 11 (11th day), ... 28 ... 31 (end of month)\\n# 1-indexed day of the month\\n\")), mdx(\"h2\", null, \"ISO Strings, UTC, what?!\"), mdx(\"h3\", null, \"Finding the UTC time\"), mdx(\"p\", null, \"In JavaScript, the UTC number returned is 13 digits for March 5th, 2021\\nIn Ruby, the UTC integer will be 10 digits when running \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"to_i\"), \" since its\\nan integer value. Why the inconsistency?\"), mdx(\"p\", null, \"In Javascript, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Date.now()\"), \" returns a millisecond based representation,\\nwhile in Ruby, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Time.current.to_i\"), \" returns a second based representation.\\nBelow, I have examples on how to make JS behave like Ruby and\\nvice-versa.\"), mdx(\"h4\", null, \"Javascript\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"Date.now()\\n// => 1614968619533\\n// Returns the numeric value corresponding to the current time\\u2014the number of milliseconds elapsed since January 1, 1970 00:00:00 UTC, with leap seconds ignored.\\n\\n// Ruby-like, second based approach\\nparseInt(Date.now() / 1000, 10)\\n// => 1614968619\\n// Without milliseconds\\n\")), mdx(\"h4\", null, \"Ruby\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\"\n  }), \"Integer(Time.current.utc)\\n# => 1614971384\\n# Returns an integer value, seconds based approach\\n\\n\\nInteger(Float(Time.current.utc) * 1000)\\n# => 1614971349307\\nReturns an integer value, milliseconds based approach\\n\")), mdx(\"h3\", null, \"ISO Strings?!\"), mdx(\"h4\", null, \"Use them in your database.\"), mdx(\"p\", null, \"ISO strings are king. Use them. Even postgres recommends them for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"date\"), \" / \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"time\"), \" / \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"datetime\"), \" columns.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.postgresql.org/docs/13/datatype-datetime.html#DATATYPE-DATETIME-DATE-TABLE\"\n  }), \"https://www.postgresql.org/docs/13/datatype-datetime.html#DATATYPE-DATETIME-DATE-TABLE\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"Example     Description\\n1999-01-08  ISO 8601; January 8 in any mode (recommended format)\\n\")), mdx(\"h4\", null, \"Look for the Z!\"), mdx(\"p\", null, \"Look for a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Z\"), \" at the end of an ISO String since\\nit will indicate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Zulu\"), \" time otherwise known as UTC time. This how you\\nwant to save times on your server. The browser is for local time, the\\nserver is for UTC time.\"), mdx(\"h4\", null, \"How to find the ISO string\"), mdx(\"p\", null, \"Here we\\u2019ll look at how to find an ISO string in JS and in Ruby. Again,\\nJS records millisecond ISO strings. Ill cover how to make both cover\\nmilliseconds.\"), mdx(\"h5\", null, \"Javascript\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"new Date().toISOString()\\n// => \\\"2021-03-05T18:45:18.661Z\\\"\\n// Javascript automatically converts to UTC when we request an ISO string\\n\")), mdx(\"p\", null, \"According to the docs it says it follows either the 24 or 27 character\\nlong approach. However, based on my testing it was always 27 character\\nmillisecond based time. My best guess is its dependent on browser. For\\nChrome, Safari, and Mozilla I got the same 27 character string. As far\\nas I can tell theres no way to force a 24 character string other than by\\npolyfilling it yourself.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString\"\n  }), \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString\")), mdx(\"h5\", null, \"Ruby\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\"\n  }), \"Time.current.iso8601\\n# => \\\"2021-03-05T13:45:46-05:00\\\"\\n# Notice this has an offset, this is not using UTC time. To get Zulu time we\\n# need to chain utc.\\n\\nTime.current.utc.iso8601\\n# => \\\"2021-03-05T18:45:54Z\\\"\\n# Without milliseconds\\n\\nTime.current.utc.iso8601(3)\\n# => \\\"2021-03-05T18:59:26.577Z\\\"\\n# With milliseconds!\\n\")), mdx(\"h3\", null, \"Full reference of above\"), mdx(\"h4\", null, \"Javascript\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Month, day, date\\n\\nconst date = new Date()\\n\\n// Month of year\\ndate.getMonth()\\n// => 0 (January), 1 (February), 2 (March), ... 11 (December)\\n// 0-indexed month of the year\\n\\n// Day of the week\\ndate.getDay()\\n// => 0 (Sunday) ... (6 Saturday)\\n// 0-indexed day of week\\n\\n// Day of the month\\ndate.getDate()\\n// => 1 (day 1 of month), ..., 11 (day 11 of month), 28 ... 31 (end of month)\\n// 1-indexed day of the month\\n\\n\\n// UTC\\nDate.now()\\n// => 1614968619533\\n// Returns the numeric value corresponding to the current time\\u2014the number of milliseconds elapsed since January 1, 1970 00:00:00 UTC, with leap seconds ignored.\\n\\n// Ruby-like, second based approach\\nparseInt(Date.now() / 1000, 10)\\n// => 1614968619\\n// Without milliseconds\\n\\n// ISO Strings\\nnew Date().toISOString()\\n// => \\\"2021-03-05T18:45:18.661Z\\\"\\n// Javascript automatically converts to UTC when we request an ISO string\\n\")), mdx(\"h4\", null, \"Ruby / Rails\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\"\n  }), \"# Month, day, date\\ntime = Time.current\\n\\n# Month of year\\ntime.month\\n# => 1 (January), 2 (February), 3 (March), ... 12 (December)\\n# 1-indexed month of the year\\n\\n# Day of the week\\ntime.wday\\n# => 0 (Sunday) ... 6 (Saturday)\\n# 0-indexed day of week\\n\\n# Day of month\\ntime.day\\n# => 1 (first day), 11 (11th day), ... 28 ... 31 (end of month)\\n# 1-indexed day of the month\\n\\n# UTC\\nInteger(Time.current.utc)\\n# => 1614971384\\n# Returns an integer value, seconds based approach\\n\\nInteger(Float(Time.current.utc) * 1000)\\n# => 1614971349307\\nReturns an integer value, milliseconds based approach\\n\\n\\n# ISO Strings\\nTime.current.iso8601\\n# => \\\"2021-03-05T13:45:46-05:00\\\"\\n# Notice this has an offset, this is not using UTC time. To get Zulu time we\\n# need to chain utc.\\n\\nTime.current.utc.iso8601\\n# => \\\"2021-03-05T18:45:54Z\\\"\\n# Without milliseconds\\n\\nTime.current.utc.iso8601(3)\\n# => \\\"2021-03-05T18:59:26.577Z\\\"\\n# With milliseconds!\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}}}}