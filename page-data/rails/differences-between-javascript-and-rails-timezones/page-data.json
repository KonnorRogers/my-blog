{"componentChunkName":"component---src-templates-blog-post-js","path":"/rails/differences-between-javascript-and-rails-timezones/","result":{"data":{"site":{"siteMetadata":{"title":"Konnor's Blog","author":"Konnor Rogers"}},"mdx":{"id":"64ced3bf-b65c-5164-9f76-c99e1a06fd59","excerpt":"What I'm working on I work for VeueLive ( https://veue.tv ) and recently was tasked with\ncreating a scheduling form for streamers. What I was tasked with: Whenâ€¦","frontmatter":{"title":"Differences between JavaScript and Rails timezones","date":"March 05, 2021"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Differences between JavaScript and Rails timezones\",\n  \"date\": \"2021-03-05T12:33:46\",\n  \"description\": \"Common pitfalls and issues with Rails timezones. Differences between the browser and the server, and various other tidbits.\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"What I\\u2019m working on\"), mdx(\"p\", null, \"I work for VeueLive (\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://veue.tv\"\n  }), \"https://veue.tv\"), \") and recently was tasked with\\ncreating a scheduling form for streamers.\"), mdx(\"h2\", null, \"What I was tasked with:\"), mdx(\"p\", null, \"When working on this I had a design that looks as follows:\"), mdx(\"form\", null, mdx(\"div\", {\n    style: {\n      \"marginBottom\": \"1rem\"\n    }\n  }, mdx(\"select\", null, mdx(\"option\", {\n    value: \"\"\n  }, \"Pick a Day\"), mdx(\"option\", {\n    value: \"1\"\n  }, \"5 March 2021 (Today) \"), mdx(\"option\", {\n    value: \"2\"\n  }, \"6 March 2021 (Tomorrow) \"), mdx(\"option\", {\n    value: \"3\"\n  }, \"7 March 2021 \"))), mdx(\"div\", null, mdx(\"select\", null, mdx(\"option\", {\n    value: \"\"\n  }, \"Pick a Time (Time Zone)\"), mdx(\"option\", {\n    value: \"15\"\n  }, \"00:15 (EST)\"), mdx(\"option\", {\n    value: \"30\"\n  }, \"00:30 (EST)\")))), mdx(\"p\", null, \"And then on the Rails backend I had a schema that looked roughly like\\nthis:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\"\n  }), \"create_table \\\"videos\\\" do |t|\\n  t.datetime :scheduled_at\\nend\\n\")), mdx(\"p\", null, \"So I had a few options, I decided to prefill a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<input type=\\\"hidden\\\"\\nname=\\\"video[scheduled_at]>\"), \" field and then use a Stimulus controller to\\nwire everything together to send off a coherent \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"datetime\"), \" to the\\nserver.\"), mdx(\"p\", null, \"Im not going to get into how I actually built this because it will be\\nquite verbose, instead, Im going to document the inconsistencies I found\\nbetween Javascript and Rails and some of the pitfalls.\"), mdx(\"h2\", null, \"Dates arent what they seem.\"), mdx(\"h3\", null, \"Month of year\"), mdx(\"p\", null, \"The month of the year is 0 indexed in JS and 1-indexed in Ruby.\"), mdx(\"h4\", null, \"Javascript\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// month of year\\nnew Date().getMonth()\\n// => 0 (January), 1 (February), 2 (March), ... 11 (December)\\n// 0-indexed month of the year\\n\")), mdx(\"h4\", null, \"Ruby / Rails\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\"\n  }), \"# month of year\\nTime.current.month\\n# => 1 (January), 2 (February), 3 (March), ... 12 (December)\\n# 1-indexed month of the year\\n\")), mdx(\"h3\", null, \"Day of Week\"), mdx(\"p\", null, \"The day of the week in JavaScript is called via:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new Date().getDay()\")), mdx(\"p\", null, \"And in Rails its:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Time.current.wday\")), mdx(\"h4\", null, \"Javascript\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Day of the week\\nnew Date().getDay()\\n// => 0 (Sunday) ... (6 Saturday)\\n// 0-indexed day of week\\n\")), mdx(\"h4\", null, \"Ruby / Rails\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\"\n  }), \"# Day of the week\\ntime.wday\\n# => 0 (Sunday) ... 6 (Saturday)\\n# 0-indexed day of week\\n\")), mdx(\"h3\", null, \"Day of Month\"), mdx(\"h4\", null, \"Javascript\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Day of the month\\ndate.getDate()\\n// => 1 (day 1 of month), ..., 11 (day 11 of month), 28 ... 31 (end of month)\\n// 1-indexed day of the month\\n\")), mdx(\"h4\", null, \"Ruby / Rails\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\"\n  }), \"# Day of month\\ntime.day\\n# => 1 (first day), 11 (11th day), ... 28 ... 31 (end of month)\\n# 1-indexed day of the month\\n\")), mdx(\"h2\", null, \"ISO Strings, UTC, what?!\"), mdx(\"h3\", null, \"Finding the UTC time\"), mdx(\"p\", null, \"In JavaScript, the UTC number returned is 13 digits for March 5th, 2021\\nIn Ruby, the UTC integer will be 10 digits when running \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"to_i\"), \" since its\\nan integer value. Why the inconsistency?\"), mdx(\"p\", null, \"In Javascript, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Date.now()\"), \" returns a millisecond based representation,\\nwhile in Ruby, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Time.current.to_i\"), \" returns a second based representation.\\nBelow, I have examples on how to make JS behave like Ruby and\\nvice-versa.\"), mdx(\"h4\", null, \"Javascript\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"Date.now()\\n// => 1614968619533\\n// Returns the numeric value corresponding to the current time\\u2014the number of milliseconds elapsed since January 1, 1970 00:00:00 UTC, with leap seconds ignored.\\n\\n// Ruby-like, second based approach\\nparseInt(Date.now() / 1000, 10)\\n// => 1614968619\\n// Without milliseconds\\n\")), mdx(\"h4\", null, \"Ruby\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\"\n  }), \"Integer(Time.current.utc)\\n# => 1614971384\\n# Returns an integer value, seconds based approach\\n\\n\\nInteger(Float(Time.current.utc) * 1000)\\n# => 1614971349307\\nReturns an integer value, milliseconds based approach\\n\")), mdx(\"h3\", null, \"ISO Strings?!\"), mdx(\"h4\", null, \"Use them in your database.\"), mdx(\"p\", null, \"ISO strings are king. Use them. Even postgres recommends them for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"date\"), \" / \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"time\"), \" / \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"datetime\"), \" columns.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.postgresql.org/docs/13/datatype-datetime.html#DATATYPE-DATETIME-DATE-TABLE\"\n  }), \"https://www.postgresql.org/docs/13/datatype-datetime.html#DATATYPE-DATETIME-DATE-TABLE\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"Example     Description\\n1999-01-08  ISO 8601; January 8 in any mode (recommended format)\\n\")), mdx(\"h4\", null, \"Look for the Z!\"), mdx(\"p\", null, \"Look for a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Z\"), \" at the end of an ISO String since\\nit will indicate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Zulu\"), \" time otherwise known as UTC time. This how you\\nwant to save times on your server. The browser is for local time, the\\nserver is for UTC time.\"), mdx(\"h4\", null, \"How to find the ISO string\"), mdx(\"p\", null, \"Here we\\u2019ll look at how to find an ISO string in JS and in Ruby. Again,\\nJS records millisecond ISO strings. Ill cover how to make both cover\\nmilliseconds.\"), mdx(\"h5\", null, \"Javascript\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"new Date().toISOString()\\n// => \\\"2021-03-05T18:45:18.661Z\\\"\\n// Javascript automatically converts to UTC when we request an ISO string\\n\")), mdx(\"p\", null, \"According to the docs it says it follows either the 24 or 27 character\\nlong approach. However, based on my testing it was always 27 character\\nmillisecond based time. My best guess is its dependent on browser. For\\nChrome, Safari, and Mozilla I got the same 27 character string. As far\\nas I can tell theres no way to force a 24 character string other than by\\npolyfilling it yourself.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString\"\n  }), \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString\")), mdx(\"h5\", null, \"Ruby\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\"\n  }), \"Time.current.iso8601\\n# => \\\"2021-03-05T13:45:46-05:00\\\"\\n# Notice this has an offset, this is not using UTC time. To get Zulu time we\\n# need to chain utc.\\n\\nTime.current.utc.iso8601\\n# => \\\"2021-03-05T18:45:54Z\\\"\\n# Without milliseconds\\n\\nTime.current.utc.iso8601(3)\\n# => \\\"2021-03-05T18:59:26.577Z\\\"\\n# With milliseconds!\\n\")), mdx(\"h3\", null, \"Full reference of above\"), mdx(\"h4\", null, \"Javascript\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Month, day, date\\n\\nconst date = new Date()\\n\\n// Month of year\\ndate.getMonth()\\n// => 0 (January), 1 (February), 2 (March), ... 11 (December)\\n// 0-indexed month of the year\\n\\n// Day of the week\\ndate.getDay()\\n// => 0 (Sunday) ... (6 Saturday)\\n// 0-indexed day of week\\n\\n// Day of the month\\ndate.getDate()\\n// => 1 (day 1 of month), ..., 11 (day 11 of month), 28 ... 31 (end of month)\\n// 1-indexed day of the month\\n\\n\\n// UTC\\nDate.now()\\n// => 1614968619533\\n// Returns the numeric value corresponding to the current time\\u2014the number of milliseconds elapsed since January 1, 1970 00:00:00 UTC, with leap seconds ignored.\\n\\n// Ruby-like, second based approach\\nparseInt(Date.now() / 1000, 10)\\n// => 1614968619\\n// Without milliseconds\\n\\n// ISO Strings\\nnew Date().toISOString()\\n// => \\\"2021-03-05T18:45:18.661Z\\\"\\n// Javascript automatically converts to UTC when we request an ISO string\\n\")), mdx(\"h4\", null, \"Ruby / Rails\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\"\n  }), \"# Month, day, date\\ntime = Time.current\\n\\n# Month of year\\ntime.month\\n# => 1 (January), 2 (February), 3 (March), ... 12 (December)\\n# 1-indexed month of the year\\n\\n# Day of the week\\ntime.wday\\n# => 0 (Sunday) ... 6 (Saturday)\\n# 0-indexed day of week\\n\\n# Day of month\\ntime.day\\n# => 1 (first day), 11 (11th day), ... 28 ... 31 (end of month)\\n# 1-indexed day of the month\\n\\n# UTC\\nInteger(Time.current.utc)\\n# => 1614971384\\n# Returns an integer value, seconds based approach\\n\\nInteger(Float(Time.current.utc) * 1000)\\n# => 1614971349307\\nReturns an integer value, milliseconds based approach\\n\\n\\n# ISO Strings\\nTime.current.iso8601\\n# => \\\"2021-03-05T13:45:46-05:00\\\"\\n# Notice this has an offset, this is not using UTC time. To get Zulu time we\\n# need to chain utc.\\n\\nTime.current.utc.iso8601\\n# => \\\"2021-03-05T18:45:54Z\\\"\\n# Without milliseconds\\n\\nTime.current.utc.iso8601(3)\\n# => \\\"2021-03-05T18:59:26.577Z\\\"\\n# With milliseconds!\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/rails/differences-between-javascript-and-rails-timezones/","previous":{"id":"6d93ea9c-b4fb-5338-b406-f6c3dbf4ff12","fields":{"slug":"/rails/active-storage-variants-rails-6-1/"},"frontmatter":{"title":"Active Storage Variants with Rails 6.1"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Active Storage Variants with Rails 6.1\",\n  \"date\": \"2021-02-24T14:12:29\",\n  \"description\": \"receiving the following error with ActiveStorage Variants with Rails 6.1? ActiveRecord::NotNullViolation (PG::NotNullViolation: ERROR:  null value in column 'record_id' of relation 'active_storage_attachments' violates not-null constraint) Let me help!\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    id: \"error\"\n  }, mdx(\"a\", {\n    href: \"#error\"\n  }, \"The Error!\")), mdx(\"p\", null, \"Upgrading to Rails 6.1 and encountering the following error?\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"ActiveRecord::NotNullViolation (PG::NotNullViolation: ERROR: null value\\nin column \\u201Crecord_id\\u201D of relation \\u201Cactive_storage_attachments\\u201D violates\\nnot-null constraint)\")), mdx(\"p\", null, \"Let me save you a couple hours!\"), mdx(\"p\", null, \"Lets back up a step. Are you using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t.uuid :record_id\"), \" (is your\\nrecord_id for ActiveStorage a uuid?)\"), mdx(\"p\", null, \"If you\\u2019re not sure, you can check your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"db/schema.rb\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\",\n    \"metastring\": \"title=db/schema.rb\",\n    \"title\": \"db/schema.rb\"\n  }), \"  create_table \\\"active_storage_attachments\\\", force: :cascade do |t|\\n    # ...\\n    t.uuid \\\"record_id\\\", null: false\\n    # ...\\n  end\\n\")), mdx(\"p\", null, \"If yes, keep reading. If not, sorry, this wont be much help.\"), mdx(\"h2\", {\n    id: \"using-uuid-me-too\"\n  }, mdx(\"a\", {\n    href: \"#using-uuid-me-too\"\n  }, \"Using UUID for record_id, cool I was too\")), mdx(\"p\", null, \"Alright now that we\\u2019ve located the source how do we fix it?\"), mdx(\"p\", null, \"When you run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rails app:update\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rails active_storage:update\"), \" it will\\ncreate 2 migrations for you. In particular we want to look at the one\\ngenerating the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"active_storage_variant_records\"), \" table. The file should look\\nsomething like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rb\",\n    \"metastring\": \"title=db/migrate/xxxx_create_active_storage_variant_records.active_storage.rb\",\n    \"title\": \"db/migrate/xxxx_create_active_storage_variant_records.active_storage.rb\"\n  }), \"class CreateActiveStorageVariantRecords < ActiveRecord::Migration[6.0]\\n  def change\\n    create_table :active_storage_variant_records do |t|\\n      t.belongs_to :blob, null: false, index: false\\n      t.string :variation_digest, null: false\\n\\n      t.index %i[ blob_id variation_digest ], name: \\\"index_active_storage_variant_records_uniqueness\\\", unique: true\\n      t.foreign_key :active_storage_blobs, column: :blob_id\\n    end\\n  end\\nend\\n\")), mdx(\"p\", null, \"From here the fix is just to add a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uuid\"), \" constraint for the id like so:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"title=db/migrate/xxxx_create_active_storage_variant_records.active_storage.rb\",\n    \"title\": \"db/migrate/xxxx_create_active_storage_variant_records.active_storage.rb\"\n  }), \"class CreateActiveStorageVariantRecords < ActiveRecord::Migration[6.0]\\n  def change\\n-    create_table :active_storage_variant_records do |t|\\n+    create_table :active_storage_variant_records, id: :uuid do |t|\\n     # ...\\n  end\\nend\\n\")), mdx(\"p\", null, \"Now rollback your migrations, rerun your migrations, and onward to\\nvictory!!\"), mdx(\"h2\", {\n    id: \"links\"\n  }, mdx(\"a\", {\n    href: \"#links\"\n  }, \"Links\")), mdx(\"h3\", {\n    id: \"active-storage-docs\"\n  }, mdx(\"a\", {\n    href: \"#active-storage-docs\"\n  }, \"Active Storage docs\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://edgeguides.rubyonrails.org/active_storage_overview.html#setup\"\n  }), \"https://edgeguides.rubyonrails.org/active_storage_overview.html#setup\"))), mdx(\"h3\", {\n    id: \"rails-6-1-migration\"\n  }, mdx(\"a\", {\n    href: \"#rails-6-1-migration\"\n  }, \"Rails 6.1 migration docs\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Release notes:\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://edgeguides.rubyonrails.org/6_1_release_notes.html\"\n  }), \"https://edgeguides.rubyonrails.org/6_1_release_notes.html\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Upgrade guide: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://guides.rubyonrails.org/upgrading_ruby_on_rails.html\"\n  }), \"https://guides.rubyonrails.org/upgrading_ruby_on_rails.html\")))));\n}\n;\nMDXContent.isMDXComponent = true;"},"next":null}}}